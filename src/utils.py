import base64
import json
import os
import random

from io import BytesIO

import pandas as pd
from reportlab.lib.pagesizes import letter
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.platypus import SimpleDocTemplate, Paragraph

from src.Character import Character


def randomize_selection(ages, jobs, races, alignments, chosen_jobs, chosen_races, chosen_ages, chosen_alignments):
    if len(chosen_jobs) < 1:
        chosen_jobs = jobs
    if len(chosen_races) < 1:
        chosen_races = races
    if len(chosen_ages) < 1:
        chosen_ages = ['young', 'adult', 'old']
    if len(chosen_alignments) < 1:
        chosen_alignments = alignments
    char_job = random.choice(chosen_jobs)
    char_race = random.choice(chosen_races)
    char_age_range = random.choice(chosen_ages)
    char_age = age_calculator(ages, char_race, char_age_range)
    char_alignment = random.choice(chosen_alignments)
    return char_job, char_race, char_age, char_alignment


def age_calculator(ages, char_race, char_age_range):
    age_ranges = ages[char_race]
    mature_age, max_age = age_ranges.split('-')
    mature_age = int(mature_age)

    check_over_max_age = False  # TODO: implement this as a message to the user
    if max_age.endswith('+'):
        max_age = int(max_age[:-1])
        check_over_max_age = True
    else:
        max_age = int(max_age)

    if char_age_range == 'young':
        char_age = random.randint(mature_age - int(mature_age * 0.4), mature_age - 1)
    elif char_age_range == 'adult':
        char_age = random.randint(mature_age, int(max_age * 0.3))
    elif char_age_range == 'old':
        char_age = random.randint(int(max_age * 0.3) + 1, max_age)
    else:
        char_age = random.randint(1, max_age)

    return char_age


def get_pdf_download_link(pdf_bytes, download_name):
    """Generate a link to download the PDF."""
    b64 = base64.b64encode(pdf_bytes).decode()
    href = f'<a href="data:file/pdf;base64,{b64}" download="{download_name}">Download PDF</a>'
    return href


def generate_pdf_npc(character):
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter, rightMargin=72)
    story = []
    styles = getSampleStyleSheet()

    text = f"""
    <p align=center spaceb=3>
    <b><font size=24>{character.name}</font></b>
    </p>
    <br/>
    <br/>
    <b>Alignment:</b> {character.alignment}
    <br/>
    <b>Job:</b> {character.job}
    <br/>
    <b>Race:</b> {character.race}
    <br/>
    <b>Age:</b> {character.age}
    <br/>
    <b>Personality:</b> {character.personality}
    <br/>
    <b>Profession:</b> {character.profession}
    <br/>
    <b>Description:</b> {character.description}
    <br/>
    <b>Marks:</b> {character.marks}
    <br/>
    <b>Background:</b> {character.background}
    <br/>
    <b>Hook:</b> {character.hook}
    <br/>
    <br/>
    This is a NPC generated by the <a href='https://github.com/SimoneVizzuso/fantasy_npc_generator' color='blue'>Fantasy NPC Generator</a>.
    """
    story.append(Paragraph(text, styles['Normal']))
    doc.build(story)

    # Get the value of the BytesIO object
    pdf_bytes = buffer.getvalue()

    return get_pdf_download_link(pdf_bytes, f"{character.name} npc character.pdf")


def save_character_json(json_file_path, cc):
    if not os.path.exists(json_file_path):
        with open(json_file_path, 'w') as json_file:
            json.dump({}, json_file, indent=4)

    with open(json_file_path, 'r') as json_file:
        characters = json.load(json_file)

    if characters:
        new_index = str(max(int(i) for i in characters.keys()) + 1)
    else:
        new_index = '1'

    characters[new_index] = {attr: value for attr, value in cc.__dict__.items()}

    with open(json_file_path, 'w') as json_file:
        json.dump(characters, json_file)


def load_characters_json(json_file_path):
    # Open the JSON file and load the data
    with open(json_file_path, 'r') as json_file:
        characters = json.load(json_file)

    if not characters:
        return [], []

    # Initialize the list of Character objects and the list of dictionaries for the DataFrame
    characters_list = []
    dataframe_list = []

    reversed_items = list(reversed(list(characters.items())))

    # Loop through the dictionary items
    for counter, (index, character_info) in enumerate(reversed_items):
        # Create a new Character object and set its attributes
        cc = Character()
        for attr, value in character_info.items():
            setattr(cc, attr, value)

        # Add the Character object to the list
        characters_list.append(cc)

        dataframe_dict = {
            'index': cc.index,
            'name': cc.name,
            'job': cc.job,
            'race': cc.race,
            'age': cc.age,
            'alignment': cc.alignment,
            'personality': cc.personality,
            'profession': cc.profession,
            'description': cc.description,
            'marks': cc.marks,
            'background': cc.background,
            'hook': cc.hook
        }

        # Add the dictionary to the list
        dataframe_list.append(dataframe_dict)

        if counter == 4:
            break

    # Create a DataFrame from the list of dictionaries
    characters_dataframe = pd.DataFrame(dataframe_list)

    return characters_list, characters_dataframe
